/*
 * BTCPay Greenfield API
 *
 * A full API to use your BTCPay Server
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct GenerateOnChainWalletRequest {
    /// An existing BIP39 mnemonic seed to generate the wallet with
    #[serde(rename = "existingMnemonic", skip_serializing_if = "Option::is_none")]
    pub existing_mnemonic: Option<String>,
    /// A passphrase for the BIP39 mnemonic seed
    #[serde(rename = "passphrase", skip_serializing_if = "Option::is_none")]
    pub passphrase: Option<String>,
    /// The account to derive from the BIP39 mnemonic seed
    #[serde(rename = "accountNumber", skip_serializing_if = "Option::is_none")]
    pub account_number: Option<f32>,
    /// Whether to store the seed inside BTCPay Server to enable some additional services. IF `false` AND `existingMnemonic` IS NOT SPECIFIED, BE SURE TO SECURELY STORE THE SEED IN THE RESPONSE!
    #[serde(rename = "savePrivateKeys", skip_serializing_if = "Option::is_none")]
    pub save_private_keys: Option<bool>,
    /// Whether to import all addresses generated via BTCPay Server into the underlying node wallet. (Private keys will also be imported if `savePrivateKeys` is set to true.
    #[serde(rename = "importKeysToRPC", skip_serializing_if = "Option::is_none")]
    pub import_keys_to_rpc: Option<bool>,
    /// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordList.
    #[serde(rename = "wordList", skip_serializing_if = "Option::is_none")]
    pub word_list: Option<WordList>,
    /// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordCount.
    #[serde(rename = "wordCount", skip_serializing_if = "Option::is_none")]
    pub word_count: Option<WordCount>,
    /// the type of wallet to generate
    #[serde(rename = "scriptPubKeyType", skip_serializing_if = "Option::is_none")]
    pub script_pub_key_type: Option<ScriptPubKeyType>,
}

impl GenerateOnChainWalletRequest {
    pub fn new() -> GenerateOnChainWalletRequest {
        GenerateOnChainWalletRequest {
            existing_mnemonic: None,
            passphrase: None,
            account_number: None,
            save_private_keys: None,
            import_keys_to_rpc: None,
            word_list: None,
            word_count: None,
            script_pub_key_type: None,
        }
    }
}

/// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordList.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WordList {
    #[serde(rename = "English")]
    English,
    #[serde(rename = "Japanese")]
    Japanese,
    #[serde(rename = "Spanish")]
    Spanish,
    #[serde(rename = "ChineseSimplified")]
    ChineseSimplified,
    #[serde(rename = "ChineseTraditional")]
    ChineseTraditional,
    #[serde(rename = "French")]
    French,
    #[serde(rename = "PortugueseBrazil")]
    PortugueseBrazil,
    #[serde(rename = "Czech")]
    Czech,
}

impl Default for WordList {
    fn default() -> WordList {
        Self::English
    }
}
/// If `existingMnemonic` is not set, a mnemonic is generated using the specified wordCount.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WordCount {
    #[serde(rename = "12")]
    _12,
    #[serde(rename = "15")]
    _15,
    #[serde(rename = "18")]
    _18,
    #[serde(rename = "21")]
    _21,
    #[serde(rename = "24")]
    _24,
}

impl Default for WordCount {
    fn default() -> WordCount {
        Self::_12
    }
}
/// the type of wallet to generate
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ScriptPubKeyType {
    #[serde(rename = "Legacy")]
    Legacy,
    #[serde(rename = "Segwit")]
    Segwit,
    #[serde(rename = "SegwitP2SH")]
    SegwitP2SH,
}

impl Default for ScriptPubKeyType {
    fn default() -> ScriptPubKeyType {
        Self::Legacy
    }
}

